import textwrap
from pathlib import Path

from gale import log
from gale.data.paths import WORKSPACE_DIR
from gale.data.projects import SHARED_PROJECT
from gale.data.structs import Board, BuildCache, BuildType, Target, get_triplet
from gale.util import CmdHandle, CmdMode, run_command


def generate_compile_commands_and_clangd_file(root_build_dir: Path) -> None:
    """Merges all found <build_dir>/<subdir>/compile_commands.json files into <build_dir>/compile_commands.json.

    This allows an LSP to have an index of the whole workspace. The compile_commands.json is in turn embedded into an
    automatically generated .clangd file.
    """
    # 1. Iterate all folders in the subdirectory with depth 1, and read all compile_commands.json files:
    merged_apps: list[str] = []
    json_file_contents: list[str] = []
    for folder in root_build_dir.iterdir():
        if folder.is_dir():
            json_file_path = folder / "compile_commands.json"
            if json_file_path.exists():
                merged_apps.append(folder.name)
                with json_file_path.open("r") as file:
                    json_file_contents.append(file.read())

    # 2. Note that the content of all the individual JSON files is an array (where each element describes a single
    # compilation unit). What we want is one mega-JSON that contains all the compilation units from all the JSON files,
    # so here we simply merge all the arrays:

    # Easiest way to merge is to:
    # 1. Pop the leading and trailing '[' and ']' from the original contents, add them
    # 2. Join all the arrays together with a comma
    # 3. Add the leading and trailing '[' and ']' back to the merged content
    json_file_contents = [json_file_content[1:-1] for json_file_content in json_file_contents]
    final_content: str = "[\n" + ",\n".join(json_file_contents) + "\n]"

    # 3. Write the final content to a file at the root of the build directory:
    merged_compile_commans_path: Path = root_build_dir / "compile_commands.json"
    with merged_compile_commans_path.open("w") as file:
        file.write(final_content)

    # 4. Generate .clangd file for the root build directory (which contains the merged compile_commands.json):
    clangd_file_content: str = textwrap.dedent(f"""
    # This file is auto-generated by gale for the latest built apps ({merged_apps}).
    CompileFlags:
      CompilationDatabase: {root_build_dir}
      Add: -Wno-unknown-warning-option
      Remove: [-m*, -f*]
    """)

    clangd_file_path: Path = WORKSPACE_DIR / ".clangd"
    with clangd_file_path.open("w") as file:
        file.write(clangd_file_content)
    log.inf(f"Generated .clangd file at {clangd_file_path} (merged from apps {merged_apps})")


class Configuration:
    def __init__(self, board: Board, target: Target, build_type: BuildType) -> None:
        self.board: Board = board
        self.target: Target = target
        self.build_type: BuildType = build_type
        self.triplet: str = get_triplet(board, target, build_type)
        self.root_build_dir: Path = self.target.parent_project.dir / "build" / self.triplet
        self.target_build_dir: Path = self.root_build_dir / self.target.build_subdir
        self._build_args_file: Path = self.target_build_dir / "build_args.txt"

    def _save_build_args(self, build_args: list[str] | None) -> None:
        """Cache the latest build arguments for later rebuilds."""
        with self._build_args_file.open("w") as f:
            f.write(" ".join(build_args) if build_args else "")
            log.inf(f"Cached build arguments into {f.name}")

    def _load_cached_build_args(self) -> list[str]:
        """Load the cached build arguments for the target."""
        try:
            with self._build_args_file.open("r") as f:
                args = f.read().split()
                log.inf(f"Loaded build arguments from {f.name}: {args}")
                return args
        except FileNotFoundError:
            log.inf(f"Build arguments file not found: {self._build_args_file}")
            return []

    def _get_extra_args_for_build_type(self, build_type: BuildType) -> list[str]:
        if build_type == BuildType.SCA:
            codechecker_config: Path = SHARED_PROJECT.dir / "share/codechecker/.codechecker.json"
            codechecker_args: str = f"--skip={SHARED_PROJECT.dir}/share/codechecker/skipfile.txt "
            codechecker_args = codechecker_args.replace(" ", ";")  # Can't have spaces in args, semicolon is alternative
            sca_args: list[str] = [
                "-DZEPHYR_SCA_VARIANT=codechecker",
                f"-DCODECHECKER_NAME={self.target.name}",
                f"-DCODECHECKER_CONFIG_FILE={codechecker_config}",
                f"-DCODECHECKER_ANALYZE_OPTS='{codechecker_args}'",
                "-DCODECHECKER_PARSE_SKIP=1",
            ]
            return sca_args
        return []

    def build(
        self,
        extra_args: list[str] | None = None,
        *,
        pristine: bool = False,
        cmake_only: bool = False,
        load_extra_args_from_disk: bool = False,
        save_extra_args_to_disk: bool = False,
    ) -> BuildCache:
        """Build the target, returning the build cache.

        Caches any build arguments to disk for later rebuilds (see `load_extra_args_from_disk`).

        Args:
            extra_args: additional arguments to pass to cmake (i.e. 'west build -- <args>');
            build_dir_suffix: suffix to append to the build directory name;
            pristine: if set, passes the --pristine flag to 'west build';
            cmake_only: if set, passes the --cmake-only flag to 'west build';
            load_extra_args_from_disk: if set, loads the latest cached build arguments from disk
                (appended to `extra_args`);
            save_extra_args_to_disk: if set, saves the provided build arguments to disk for later rebuilds.
                (cannot be used together with `load_extra_args_from_disk`, as this could easily cause weird issues)
        """
        if load_extra_args_from_disk and save_extra_args_to_disk:
            msg = "Cannot load and save build arguments simultaneously; might cause the same arguments to build up."
            raise ValueError(msg)

        if extra_args is None:
            extra_args = []
        extra_args = extra_args + self._get_extra_args_for_build_type(self.build_type)

        if load_extra_args_from_disk:
            extra_args = extra_args + self._load_cached_build_args()
        args: str = " ".join(extra_args) if extra_args else ""

        self.target.pre_build(self.root_build_dir)
        build_cmd: str = (
            "west build"
            + f" -s {self.target.parent_project.dir}"
            + f" -d {self.root_build_dir}"
            + f" -t {self.target.cmake_target}"
            + f" -b {self.board.primary_board}"
            + " --sysbuild"  # In case of nrf-sdk, sysbuild is implied by default, but can still set explicitly.
            + (" --pristine" if pristine else "")
            + (" --cmake-only" if cmake_only else "")
            + " --"
            + f" {args}"
        )
        build_res: CmdHandle = run_command(
            cmd=build_cmd,
            desc=f"Building target '{self.target.name}' for board '{self.board.name}'",
            mode=CmdMode.FOREGROUND,
            fatal=False,
        )

        # We use non-fatal build above because we want to try generate the clangd file even if the build fails but
        # the configuration succeeded. However, it might not have, so this generation may fail:
        try:
            generate_compile_commands_and_clangd_file(self.root_build_dir)
        except Exception as e:  # noqa: BLE001
            log.wrn(f"Failed to generate clangd file: {e}")

        if build_res.code != 0:
            log.fatal("Build failed")

        if save_extra_args_to_disk:
            self._save_build_args(extra_args)

        build_cache: BuildCache = self.get_build_cache()
        self.target.post_build(build_cache)
        return build_cache

    def get_build_cache(self) -> BuildCache:
        """Return the build cache for a previously built target.

        Target must have been built first (cache files must exist on disk), otherwise an error is raised.
        """
        return BuildCache(self.board, self.target, self.build_type, self.target_build_dir)
