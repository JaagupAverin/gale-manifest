import shutil
import textwrap
from pathlib import Path

from gale import log
from gale.configuration import Configuration
from gale.data.boards import get_board
from gale.data.projects import MANIFEST_PROJECT, SHARED_PROJECT, ZEPHYR_PROJECT
from gale.data.structs import Board, BuildCache, Target
from gale.util import CmdMode, run_command, source_environment


def task_generate_clangd_file(cache: BuildCache) -> None:
    """Writes a .clangd file for the given build cache in gale root directory, in order to benefit LSPs."""
    clangd_file_content = textwrap.dedent(f"""
    # This file is auto-generated by gale for the latest built target ({cache.triplet}).
    CompileFlags:
      CompilationDatabase: {cache.build_dir}
      Add: -Wno-unknown-warning-option
      Remove: [-m*, -f*]
    """)

    clangd_file_path = MANIFEST_PROJECT.dir / ".clangd"
    log.inf(f"Generating .clangd file at {clangd_file_path}")
    with clangd_file_path.open("w") as file:
        file.write(clangd_file_content)


def common_post_build_task(cache: BuildCache) -> None:
    """Common post-build steps for most targets.

    * Generates a .clangd file at gale root directory for an LSP.
    """
    task_generate_clangd_file(cache)


def _run_app_in_bsim(  # noqa: PLR0915
    cache: BuildCache,
    *,
    gdb: bool,
    real_time: bool,
    tracing: bool = True,
) -> None:
    """Given that the target was built as a BabbleSim executable, runs the binary natively.

    This entails:
    1. Copying the required bsim binaries/libraries and the target binary to a common directory;
    2. Creating a common simulation ID;
    3. Running the target binary device;
    4. Running optional devices, such as the handbrake device (if "real time" execution is required);
    5. Running the phy layer;

    Args:
        cache: used to locate all build artifacts, and determine location of tools, such as gdb or BabbleSim.
        gdb: if True, runs the app with gdb (client with TUI);
        real_time: if True, the simulation will run in "real time", i.e K_SECONDS(1) corresponds to 1 second in reality;
            if False, the simulation runs at maximum speed (limited only by host CPU); good for running tests;
        tracing: if True, passes the --trace-file argument to the BabbleSim executable in order to store trace data
            (trace data is stored into the final run/results directory);
        trace_dir: if True, generated trace data into the specified directory;
            if False, trace data is still be generated, but into an unspecified directory;
    """
    source_environment(cache.board.env)

    exe: Path = Path(cache.cmake_cache.exe_path)
    if not exe.exists():
        log.fatal(f"Output binary '{exe}' does not exist; use build first.")

    # Inputs:
    bsim_build_dir: Path = Path(cache.cmake_cache.bsim_out_path)
    bsim_bin_dir: Path = bsim_build_dir / "bin"
    bsim_lib_dir: Path = bsim_build_dir / "lib"

    # Outputs:
    final_dir: Path = cache.target.parent_project.dir / "bsim"
    final_bin_dir: Path = final_dir / "bin"
    final_lib_dir: Path = final_dir / "lib"
    final_results_dir: Path = final_dir / "results"

    final_dir.mkdir(parents=True, exist_ok=True)
    final_results_dir.mkdir(parents=True, exist_ok=True)

    common_args = ""

    # All devices shall be "linked together" by the same simulation ID;
    # Once the phy is executed, all devices with the same simulation ID will share the same phy:
    sim_id: str = cache.target.name
    num_devices: int = 0

    # 1. Prepare simulation environment by copying the bsim binaries and libraries to the final folder:
    log.dbg(f"Preparing to run executable inside {final_bin_dir}")
    shutil.copytree(bsim_bin_dir, final_bin_dir, dirs_exist_ok=True)
    shutil.copytree(bsim_lib_dir, final_lib_dir, dirs_exist_ok=True)

    # 2. Copy the app device itself to the final folder:
    log.dbg(f"Copying executable from {exe}")
    final_exe: str = str(shutil.copy(exe, final_bin_dir))

    # 3. Prepare tracing if required:
    if tracing:
        # Copy Zephyr's metadata file to same directory as our final trace data file:
        trace_metadata = f"{ZEPHYR_PROJECT.dir / 'subsys/tracing/ctf/tsdl/metadata'}"
        shutil.copy(trace_metadata, final_results_dir / "metadata")

        # Tell application to output trace data to custom file:
        trace_file_arg = f"--trace-file={final_results_dir}/trace_data"
        common_args += f" {trace_file_arg}"

    # Use a well-defined path for the flash binary, which is used for persistent storage of flash data:
    simulated_flash_bin_arg: str = f"--flash={final_results_dir}/flash.bin"
    common_args += f" {simulated_flash_bin_arg}"

    # How often the handbrake triggers or "pokes" the simulation:
    # Decreasing improves responsiveness, but increases overhead; should not be reduced below 2ms.
    bsim_handbrake_interval_nsec: int = 5_000
    if real_time:
        # MRO: Max Resync Offset; determines max offset from PHY time before the app must resync;
        # default value is 1sec, but lowering this makes the app more responsive,
        # which is especially important if using handbrake and responsiveness is needed.
        common_args += f" --mro={bsim_handbrake_interval_nsec}"

    # 4. Run application device itself:
    if gdb:
        gdbinit: Path = SHARED_PROJECT.dir / "gdb/.gdbconf"
        # In case of debugging, we cannot attach to UART in the same terminal as gdb, so instead we
        # print out a message instructing the user to attach the UART, and wait until it is attached.
        # TODO: Can launch with gdbserver instead in the future if want to attach from IDE.
        uart_attach_cmd: str = r"echo App\ halted\ until\ UART\ attached!\ Use:\ gale\ monitor\ --port\ %s"
        uart_args = f'--uart_pty_wait --uart1_pty_attach_cmd="{uart_attach_cmd}"'
        app_run_cmd: str = (
            f"{cache.cmake_cache.gdb} --tui -x {gdbinit} --args "
            f"{final_exe} -s={sim_id} -d={num_devices} {uart_args} {common_args}"
        )
        num_devices += 1
        run_command(
            cmd=app_run_cmd,
            desc=f"Running target '{cache.target.name}' device in BabbleSim",
            cwd=final_bin_dir,
            mode=CmdMode.SPAWN_NEW_TERMINAL,
        )
    else:
        # In case of running directly, attach the UART immediately:
        uart_attach_cmd = "gale monitor --port %s --new-terminal"
        uart_args = f'--uart_pty_wait --uart1_pty_attach_cmd="{uart_attach_cmd}"'
        app_run_cmd = f"{final_exe} -s={sim_id} -d={num_devices} {uart_args} {common_args}"
        num_devices += 1
        run_command(
            cmd=app_run_cmd,
            desc=f"Running target '{cache.target.name}' device in BabbleSim",
            cwd=final_bin_dir,
            mode=CmdMode.BACKGROUND,
        )

    # 5. Run the handbrake device, if real time is requested:
    if real_time:
        handbrake_run_cmd: str = (
            f"./bs_device_handbrake -s={sim_id} -d={num_devices} --pp={bsim_handbrake_interval_nsec}"
        )
        num_devices += 1
        run_command(
            cmd=handbrake_run_cmd,
            desc="Running handbrake device in BabbleSim",
            cwd=final_bin_dir,
            mode=CmdMode.BACKGROUND,
        )

    # 6. Run the PHY itself, which starts the simulation proper:
    phy_run_cmd: str = f"./bs_2G4_phy_v1 -s={sim_id} -D={num_devices}"
    run_command(
        cmd=phy_run_cmd,
        desc="Starting BabbleSim PHY",
        cwd=final_bin_dir,
        mode=CmdMode.FOREGROUND,
    )


def common_run_task(cache: BuildCache, *, gdb: bool, real_time: bool) -> None:
    """Common run steps for most targets.

    * For BabbleSim builds, runs the natively built binary directly.
    """
    if cache.board.is_bsim:
        _run_app_in_bsim(cache, gdb=gdb, real_time=real_time)
    else:
        log.fatal("Direct running on board not yet implemented.")


def run_sca(board: Board, target: Target) -> None:
    """Run the SCA server for the given build cache."""
    # 1. Build the target with SCA enabled
    sca_args: list[str] = [
        "--",
        "-DZEPHYR_SCA_VARIANT=codechecker",
        f"-DCODECHECKER_NAME={target.name}",
    ]
    conf: Configuration = Configuration(board, target)
    cache: BuildCache = conf.build(extra_args=sca_args, load_extra_args_from_disk=True)
    sca_results_dir: Path = cache.build_dir / "sca" / "codechecker" / "codechecker.plist"

    # 2. Start the SCA server
    run_command(
        cmd=f"{cache.cmake_cache.codechecker_exe} server",
        desc="Running SCA server",
        cwd=cache.build_dir,
        mode=CmdMode.BACKGROUND,
    )

    # 3. Store the analysis results into server
    run_command(
        cmd=f"{cache.cmake_cache.codechecker_exe} store {sca_results_dir} -n {target.name}",
        desc="Storing analysis results into SCA server",
        cwd=cache.build_dir,
        mode=CmdMode.FOREGROUND,
    )

    # 4. Open localhost:8001 in native browser
    run_command(
        cmd="open http://localhost:8001",
        desc="Opening SCA server in browser",
        cwd=cache.build_dir,
        mode=CmdMode.FOREGROUND,
    )

    # TODO: Actually get this working. rn server crashes like a sucker
