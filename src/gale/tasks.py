import textwrap
from pathlib import Path

from gale import log
from gale.data.projects import MANIFEST_PROJECT
from gale.data.structs import BuildCache
from gale.util import CmdMode, run_command


def task_generate_clangd_file(cache: BuildCache) -> None:
    """Writes a .clangd file for the given build cache in gale root directory, in order to benefit LSPs."""
    clangd_file_content = textwrap.dedent(f"""
    # This file is auto-generated by gale for the latest built target ({cache.triplet}).
    CompileFlags:
      CompilationDatabase: {cache.build_dir}
      Add: -Wno-unknown-warning-option
      Remove: [-m*, -f*]
    """)

    clangd_file_path = MANIFEST_PROJECT.dir / ".clangd"
    log.inf(f"Generating .clangd file at {clangd_file_path}")
    with clangd_file_path.open("w") as file:
        file.write(clangd_file_content)


def common_post_build_task(cache: BuildCache) -> None:
    """Common post-build steps for most targets.

    * Generates a .clangd file at gale root directory for an LSP.
    """
    task_generate_clangd_file(cache)


def _get_bsim_run_cmd(cache: BuildCache, user_args: list[str] | None, *, attach_to_uart: bool) -> str:
    """Given that the target was built as a native BabbleSim executable, return a command to run it natively.

    The returned command is effectively a path to the executable, with added arguments that simplify monitoring.
    """
    args: str = " ".join(user_args) if user_args else ""

    exe: Path = Path(cache.cmake_cache.exe_path)
    if not exe.exists():
        log.fatal(f"Output binary '{exe}' does not exist; use build first.")

    if attach_to_uart:
        attach_cmd: str = "gale monitor --port %s --terminal"
    else:
        # Don't actually attach, but print out HOW to attach, a bit more flexible and stable this way,
        attach_cmd = 'echo "\033[31m >>> Program paused until monitoring! Use: gale monitor --port %s\033[0m"'

    run_cmd: str = f"{exe} --nosim {args} --wait_uart --attach_uart_cmd='{attach_cmd}'"
    return run_cmd


def common_run_task(cache: BuildCache, extra_args: list[str] | None) -> None:
    """Common run steps for most targets.

    * For BabbleSim builds, runs the natively built binary directly.
    """
    if cache.board.is_bsim:
        run_command(
            cmd=_get_bsim_run_cmd(cache, extra_args, attach_to_uart=True),
            desc=f"Running '{cache.triplet}' natively",
            mode=CmdMode.REPLACE,
        )
    else:
        log.fatal("Direct running on board not yet implemented.")


def common_debug_task(cache: BuildCache, extra_args: list[str] | None) -> None:
    """Common debug steps for most targets.

    * For BabbleSim builds, runs the natively built binary through gdb.
    """
    if cache.board.is_bsim:
        # Don't automatically attach to UART because its a bit unstable when called in combination with gdb:
        run_cmd: str = _get_bsim_run_cmd(cache, extra_args, attach_to_uart=False)
        dbg_cmd: str = f"{cache.cmake_cache.gdb} --tui --args {run_cmd}"
        run_command(cmd=dbg_cmd, desc=f"Debugging '{cache.triplet}' natively", mode=CmdMode.REPLACE)
    else:
        log.fatal("Direct debugging on board not yet implemented.")
